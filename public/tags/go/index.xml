<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on Duken Marga</title><link>https://dukenmarga.id/tags/go/</link><description>Recent content in Go on Duken Marga</description><generator>Hugo</generator><language>en</language><lastBuildDate>Mon, 14 Jul 2025 00:00:00 +0700</lastBuildDate><atom:link href="https://dukenmarga.id/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Error Handling in Go</title><link>https://dukenmarga.id/post/error-handling-in-go/</link><pubDate>Mon, 14 Jul 2025 00:00:00 +0700</pubDate><guid>https://dukenmarga.id/post/error-handling-in-go/</guid><description>&lt;h3 id="error-as-value">Error As Value&lt;/h3>
&lt;p>Error is treated as value in Go. No &lt;code>try/catch&lt;/code>, but there is &lt;code>panic/recover&lt;/code>.
Other programming languages is using &lt;code>try/catch&lt;/code> for regular error,
while Go use &lt;code>panic/recover&lt;/code> for fatal or unrecoverable condition such
as nil pointer dereference and so on.
Hence, &lt;code>panic/recover&lt;/code> is not a direct replacement for &lt;code>try/catch&lt;/code>.&lt;/p>
&lt;p>For regular error, we need to return it like we return a variable.
Some people are alright with this decision, but some are not because
it makes the code verbose and you will find &lt;code>if err != nil&lt;/code> are everywhere.&lt;/p></description></item></channel></rss>